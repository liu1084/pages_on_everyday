## mybatis批处理

-   批量插入

```sql
<insert id="batchInsert">
insert into 
    user(id, gmt_create, gmt_modified, username, age, sex, phone)
    values
    <foreatch item="user" collection="userList" separator=",">
    (#{user.id}, now(), now(), #{user.username}, #{user.age}, #{user.sex}, #{user.phone})
    </foreatch>
</insert>
```



-   批量更新

```sql
<update id="batchUpdate">
update user set 
    age = #{age}
where id in 
    <foreatch item=id collection="idList" open="(" separator="," close=")">
    #{id}
    </foreatch>
</update>
```



-   批量删除

```sql
<delete id="batchDelete">
delete from user 
where id in 
    <foreatch item=id collection="idList" open="(" separator="," close=")">
    #{id}
    </foreatch>
</update>
```



 用sql批量处理方式存在局限性，最明显的是长度问题，另外就是`in`条件存在性能问题。 

```java
@Autowired
private SqlSessionFactory sqlSessionFactory;

private SqlSession batchSqlSession;

@PostConstruct
public void init() {
    // 初始化批量处理的sql session
    batchSqlSession = new SqlSessionTemplate(sqlSessionFactory, ExecutorType.BATCH);
}

public int batchUpdate(String statementId, List<Map<String, Object>> params) {

    List<BatchResult> batchResults = new ArrayList<>();

    int batchSize = 0;
    for (Map<String, Object> param : params) {
        batchSqlSession.update(statementId, param);
        batchSize++;
        if (batchSize == 50) {
            batchResults.addAll(batchSqlSession.flushStatements());
            batchSize = 0;
        }
    }

    if (batchSize > 0) {
        batchResults.addAll(batchSqlSession.flushStatements());
    }

    return batchResults.stream().map(BatchResult::getUpdateCounts).flatMapToInt(Arrays::stream).sum();
}
```

